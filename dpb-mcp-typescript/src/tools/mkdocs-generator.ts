import * as fs from 'fs/promises';
import * as path from 'path';
import { readComposerJson } from '../utils/composer-utils.js';
import { analyzeDependencies } from './dependency-analyzer.js';
import { analyzePSR4Autoloading } from './psr4-analyzer.js';
import { detectNamespaces } from './namespace-detector.js';
import { auditSecurityIssues } from './security-auditor.js';
import { analyzeLicenses } from './license-analyzer.js';
import { generateDependencyGraph } from './graph-generator.js';
import { createDependencySnapshot, loadTracker, compareSnapshots, DependencyChange } from './dependency-tracker.js';

export interface MkDocsOptions {
  repoPath: string;
  outputDir?: string;
  includeChangelog?: boolean;
  format?: 'mkdocs' | 'html' | 'markdown';
  siteName?: string;
  siteDescription?: string;
}

/**
 * Generate MkDocs-compatible documentation structure
 */
export async function generateMkDocsDocs(options: MkDocsOptions): Promise<string> {
  const {
    repoPath,
    outputDir = path.join(repoPath, 'docs'),
    includeChangelog = true,
    format = 'mkdocs',
    siteName,
    siteDescription,
  } = options;

  // Ensure output directory exists
  await fs.mkdir(outputDir, { recursive: true });

  // Gather all analysis data
  const composer = await readComposerJson(repoPath);
  const deps = await analyzeDependencies(repoPath);
  const psr4 = await analyzePSR4Autoloading(repoPath);
  const namespaces = await detectNamespaces(repoPath);
  const security = await auditSecurityIssues(repoPath);
  const licenses = await analyzeLicenses(repoPath);
  const depGraph = await generateDependencyGraph(repoPath, { maxDepth: 2 });

  // Get project info
  const projectName = siteName || composer.name || path.basename(repoPath);
  const projectDesc = siteDescription || composer.description || 'Dependency Analysis Documentation';

  // Generate changelog if requested
  let changelogContent = '';
  if (includeChangelog) {
    changelogContent = await generateChangelog(repoPath);
  }

  // Generate individual markdown files
  const indexContent = generateIndex(projectName, projectDesc, composer, deps);
  const dependenciesContent = generateDependenciesDoc(deps, depGraph);
  const securityContent = generateSecurityDoc(security);
  const licensesContent = generateLicensesDoc(licenses);
  const architectureContent = generateArchitectureDoc(psr4, namespaces);

  // Write markdown files
  await fs.writeFile(path.join(outputDir, 'index.md'), indexContent);
  await fs.writeFile(path.join(outputDir, 'dependencies.md'), dependenciesContent);
  await fs.writeFile(path.join(outputDir, 'security.md'), securityContent);
  await fs.writeFile(path.join(outputDir, 'licenses.md'), licensesContent);
  await fs.writeFile(path.join(outputDir, 'architecture.md'), architectureContent);
  
  if (changelogContent) {
    await fs.writeFile(path.join(outputDir, 'changelog.md'), changelogContent);
  }

  // Generate mkdocs.yml if format is mkdocs
  if (format === 'mkdocs') {
    const mkdocsConfig = generateMkDocsConfig(projectName, projectDesc, includeChangelog);
    await fs.writeFile(path.join(outputDir, 'mkdocs.yml'), mkdocsConfig);
  }

  // Generate HTML if requested
  if (format === 'html') {
    const htmlContent = generateHTMLSite({
      siteName: projectName,
      siteDescription: projectDesc,
      index: indexContent,
      dependencies: dependenciesContent,
      security: securityContent,
      licenses: licensesContent,
      architecture: architectureContent,
      changelog: changelogContent,
    });
    await fs.writeFile(path.join(outputDir, 'index.html'), htmlContent);
  }

  return `Documentation generated successfully in ${outputDir}`;
}

/**
 * Generate index.md (overview)
 */
function generateIndex(
  projectName: string,
  description: string,
  composer: any,
  deps: any
): string {
  const now = new Date().toISOString();
  return `# ${projectName}

${description}

**Generated:** ${now}

## Quick Overview

- **Project Type:** ${composer.type || 'library'}
- **License:** ${Array.isArray(composer.license) ? composer.license.join(', ') : composer.license || 'Not specified'}
- **Production Dependencies:** ${deps.stats.totalProduction}
- **Development Dependencies:** ${deps.stats.totalDevelopment}

## Documentation Sections

- [Dependencies](./dependencies.md) - Complete dependency analysis and tree
- [Security](./security.md) - Security audit and vulnerability report
- [Licenses](./licenses.md) - License compliance and distribution
- [Architecture](./architecture.md) - Namespace structure and PSR-4 compliance
${deps.stats.totalProduction > 0 ? '- [Changelog](./changelog.md) - Dependency change history\n' : ''}

## Getting Started

This documentation was automatically generated by dependency-buster MCP.

To view with MkDocs:
\`\`\`bash
cd docs
mkdocs serve
\`\`\`
`;
}

/**
 * Generate dependencies.md
 */
function generateDependenciesDoc(deps: any, graph: string): string {
  let content = `# Dependencies

## Summary

- **Production:** ${deps.stats.totalProduction} packages
- **Development:** ${deps.stats.totalDevelopment} packages
- **Total:** ${deps.stats.totalProduction + deps.stats.totalDevelopment} packages

## Dependency Graph

\`\`\`mermaid
${graph}
\`\`\`

## Production Dependencies

`;

  if (deps.production && Object.keys(deps.production).length > 0) {
    content += '| Package | Version |\n';
    content += '|---------|----------|\n';
    for (const [name, version] of Object.entries(deps.production).slice(0, 50)) {
      content += `| \`${name}\` | \`${version}\` |\n`;
    }
    if (Object.keys(deps.production).length > 50) {
      content += `\n*... and ${Object.keys(deps.production).length - 50} more*\n`;
    }
  } else {
    content += '*No production dependencies found.*\n';
  }

  content += '\n## Development Dependencies\n\n';

  if (deps.development && Object.keys(deps.development).length > 0) {
    content += '| Package | Version |\n';
    content += '|---------|----------|\n';
    for (const [name, version] of Object.entries(deps.development).slice(0, 50)) {
      content += `| \`${name}\` | \`${version}\` |\n`;
    }
    if (Object.keys(deps.development).length > 50) {
      content += `\n*... and ${Object.keys(deps.development).length - 50} more*\n`;
    }
  } else {
    content += '*No development dependencies found.*\n';
  }

  return content;
}

/**
 * Generate security.md
 */
function generateSecurityDoc(security: any): string {
  let content = `# Security Audit

## Risk Level: ${security.riskLevel.toUpperCase()}

## Summary

- **Critical:** ${security.summary.critical}
- **High:** ${security.summary.high}
- **Medium:** ${security.summary.medium}
- **Low:** ${security.summary.low}
- **Total Issues:** ${security.vulnerabilities.length}

`;

  if (security.vulnerabilities.length > 0) {
    content += '## Vulnerabilities\n\n';
    content += '| Package | Version | Severity | Description |\n';
    content += '|---------|---------|----------|-------------|\n';
    
    for (const vuln of security.vulnerabilities.slice(0, 100)) {
      content += `| \`${vuln.package}\` | \`${vuln.version || 'N/A'}\` | ${vuln.severity} | ${vuln.description || 'N/A'} |\n`;
    }
    
    if (security.vulnerabilities.length > 100) {
      content += `\n*... and ${security.vulnerabilities.length - 100} more vulnerabilities*\n`;
    }
  } else {
    content += '## Status\n\n✅ No known vulnerabilities found.\n';
  }

  return content;
}

/**
 * Generate licenses.md
 */
function generateLicensesDoc(licenses: any): string {
  let content = `# License Compliance

## Summary

- **Total Packages:** ${licenses.summary.totalPackages}
- **Unique Licenses:** ${licenses.summary.uniqueLicenses}
- **Unknown Licenses:** ${licenses.summary.unknownLicenses}

## License Distribution

`;

  if (licenses.distribution && licenses.distribution.length > 0) {
    content += '| License | Count | Percentage |\n';
    content += '|---------|-------|------------|\n';
    
    const total = licenses.summary.totalPackages;
    for (const dist of licenses.distribution) {
      const percentage = total > 0 ? ((dist.count / total) * 100).toFixed(1) : '0.0';
      content += `| ${dist.license} | ${dist.count} | ${percentage}% |\n`;
    }
  } else {
    content += '*No license information available.*\n';
  }

  if (licenses.compatibilityIssues && licenses.compatibilityIssues.length > 0) {
    content += '\n## Compatibility Issues\n\n';
    content += '| Package | License | Issue |\n';
    content += '|---------|---------|-------|\n';
    
    for (const issue of licenses.compatibilityIssues) {
      content += `| \`${issue.package}\` | ${issue.license} | ${issue.issue} |\n`;
    }
  }

  return content;
}

/**
 * Generate architecture.md
 */
function generateArchitectureDoc(psr4: any, namespaces: any): string {
  let content = `# Architecture

## PSR-4 Autoloading

### Summary

- **Total Mappings:** ${psr4.stats.totalMappings}
- **Files Analyzed:** ${psr4.stats.totalFiles}
- **PSR-4 Compliant:** ${psr4.stats.validFiles}
- **Violations:** ${psr4.stats.violationCount}

`;

  if (psr4.mappings && Object.keys(psr4.mappings).length > 0) {
    content += '### Mappings\n\n';
    content += '| Namespace Prefix | Directory |\n';
    content += '|------------------|-----------|\n';
    
    for (const [prefix, dir] of Object.entries(psr4.mappings).slice(0, 20)) {
      content += `| \`${prefix}\` | \`${dir}\` |\n`;
    }
    
    if (Object.keys(psr4.mappings).length > 20) {
      content += `\n*... and ${Object.keys(psr4.mappings).length - 20} more mappings*\n`;
    }
  }

  content += '\n## Namespaces\n\n';

  if (namespaces.namespaces && namespaces.namespaces.length > 0) {
    content += `Found **${namespaces.namespaces.length}** namespaces:\n\n`;
    
    for (const ns of namespaces.namespaces.slice(0, 30)) {
      content += `- \`${ns.namespace}\` (${ns.files.length} files)\n`;
    }
    
    if (namespaces.namespaces.length > 30) {
      content += `\n*... and ${namespaces.namespaces.length - 30} more namespaces*\n`;
    }
  } else {
    content += '*No namespaces detected.*\n';
  }

  return content;
}

/**
 * Generate changelog.md from dependency snapshots
 */
async function generateChangelog(repoPath: string): Promise<string> {
  try {
    const currentSnapshot = await createDependencySnapshot(repoPath);
    let oldSnapshot;
    try {
      oldSnapshot = await loadTracker(repoPath);
    } catch {
      oldSnapshot = null;
    }
    
    if (!oldSnapshot) {
      return `# Dependency Changelog

## ${new Date().toISOString().split('T')[0]}

Initial snapshot created.

**Total Dependencies:** ${currentSnapshot.metadata.totalCount}
`;
    }

    const changes = compareSnapshots(oldSnapshot, currentSnapshot);
    
    if (changes.length === 0) {
      return `# Dependency Changelog

## ${new Date().toISOString().split('T')[0]}

No changes detected since last snapshot.

**Total Dependencies:** ${currentSnapshot.metadata.totalCount}
`;
    }

    // Group changes by date
    const changesByDate = new Map<string, DependencyChange[]>();
    for (const change of changes) {
      const date = change.timestamp.split('T')[0];
      if (!changesByDate.has(date)) {
        changesByDate.set(date, []);
      }
      changesByDate.get(date)!.push(change);
    }

    let content = `# Dependency Changelog

## ${new Date().toISOString().split('T')[0]}

### Summary

- **Added:** ${changes.filter(c => c.type === 'added').length}
- **Updated:** ${changes.filter(c => c.type === 'updated').length}
- **Removed:** ${changes.filter(c => c.type === 'removed').length}

`;

    // Group by type
    const added = changes.filter(c => c.type === 'added');
    const updated = changes.filter(c => c.type === 'updated');
    const removed = changes.filter(c => c.type === 'removed');

    if (added.length > 0) {
      content += '### Added\n\n';
      for (const change of added) {
        content += `- \`${change.name}\` \`${change.newVersion}\`\n`;
      }
      content += '\n';
    }

    if (updated.length > 0) {
      content += '### Updated\n\n';
      for (const change of updated) {
        content += `- \`${change.name}\`: \`${change.oldVersion}\` → \`${change.newVersion}\`\n`;
      }
      content += '\n';
    }

    if (removed.length > 0) {
      content += '### Removed\n\n';
      for (const change of removed) {
        content += `- \`${change.name}\` \`${change.oldVersion}\`\n`;
      }
      content += '\n';
    }

    return content;
  } catch (error) {
    return `# Dependency Changelog

*Unable to generate changelog: ${error instanceof Error ? error.message : 'Unknown error'}*
`;
  }
}

/**
 * Generate mkdocs.yml configuration
 */
function generateMkDocsConfig(siteName: string, siteDescription: string, includeChangelog: boolean): string {
  const nav: string[] = [
    'Home: index.md',
    'Dependencies: dependencies.md',
    'Security: security.md',
    'Licenses: licenses.md',
    'Architecture: architecture.md',
  ];

  if (includeChangelog) {
    nav.push('Changelog: changelog.md');
  }

  return `site_name: ${siteName}
site_description: ${siteDescription}
site_url: https://example.com

theme:
  name: material
  palette:
    primary: blue
    accent: blue

markdown_extensions:
  - pymdownx.highlight:
      anchor_linenums: true
  - pymdownx.inlinehilite
  - pymdownx.snippets
  - pymdownx.superfences:
      custom_fences:
        - name: mermaid
          class: mermaid
          format: !!python/name:pymdownx.superfences.fence_code_format

nav:
${nav.map(item => `  - ${item}`).join('\n')}
`;
}

/**
 * Generate self-contained HTML site
 */
function generateHTMLSite(content: {
  siteName: string;
  siteDescription: string;
  index: string;
  dependencies: string;
  security: string;
  licenses: string;
  architecture: string;
  changelog: string;
}): string {
  // Simple HTML with embedded CSS and navigation
  // In production, you'd use a proper markdown-to-HTML converter
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${content.siteName}</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
    nav { background: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
    nav a { margin-right: 20px; text-decoration: none; color: #0066cc; }
    nav a:hover { text-decoration: underline; }
    h1 { color: #333; }
    h2 { color: #555; margin-top: 30px; }
    code { background: #f5f5f5; padding: 2px 6px; border-radius: 3px; }
    pre { background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; }
    table { border-collapse: collapse; width: 100%; margin: 20px 0; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background: #f5f5f5; }
  </style>
</head>
<body>
  <nav>
    <a href="#index">Home</a>
    <a href="#dependencies">Dependencies</a>
    <a href="#security">Security</a>
    <a href="#licenses">Licenses</a>
    <a href="#architecture">Architecture</a>
    ${content.changelog ? '<a href="#changelog">Changelog</a>' : ''}
  </nav>
  
  <div id="index">
    <h1>${content.siteName}</h1>
    <p>${content.siteDescription}</p>
    <p><em>Note: This is a basic HTML preview. For full features, use MkDocs.</em></p>
  </div>
  
  <div id="content">
    <div id="index-content"></div>
    <div id="dependencies-content"></div>
    <div id="security-content"></div>
    <div id="licenses-content"></div>
    <div id="architecture-content"></div>
    ${content.changelog ? '<div id="changelog-content"></div>' : ''}
  </div>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    function markdownToHTML(md) {
      if (typeof marked !== 'undefined') {
        return marked.parse(md);
      }
      // Fallback basic conversion
      return md
        .replace(/^# (.*$)/gim, '<h1>$1</h1>')
        .replace(/^## (.*$)/gim, '<h2>$1</h2>')
        .replace(/^### (.*$)/gim, '<h3>$1</h3>')
        .replace(/\\*\\*(.*?)\\*\\*/gim, '<strong>$1</strong>')
        .replace(/\\*(.*?)\\*/gim, '<em>$1</em>')
        .replace(/\x60([^\x60]+)\x60/gim, '<code>$1</code>')
        .replace(/\\n/gim, '<br>');
    }
    
    // Escape markdown for JavaScript template literals
    function escapeTemplateLiteral(s) {
      return s
        .replace(/\\\\/g, '\\\\\\\\')  // Escape backslashes
        .replace(/\`/g, '\\\\`')       // Escape backticks
        .replace(/\$/g, '\\\\$')      // Escape dollar signs
        .replace(/\n/g, '\\\\n')      // Escape newlines
        .replace(/\r/g, '\\\\r');      // Escape carriage returns
    }
    
    const indexMD = \`${escapeTemplateLiteral(content.index)}\`;
    const depsMD = \`${escapeTemplateLiteral(content.dependencies)}\`;
    const secMD = \`${escapeTemplateLiteral(content.security)}\`;
    const licMD = \`${escapeTemplateLiteral(content.licenses)}\`;
    const archMD = \`${escapeTemplateLiteral(content.architecture)}\`;
    ${content.changelog ? `const changelogMD = \`${escapeTemplateLiteral(content.changelog)}\`;` : 'const changelogMD = "";'}
    
    // Wait for DOM to be ready
    function renderContent() {
      document.getElementById('index-content').innerHTML = markdownToHTML(indexMD);
      document.getElementById('dependencies-content').innerHTML = markdownToHTML(depsMD);
      document.getElementById('security-content').innerHTML = markdownToHTML(secMD);
      document.getElementById('licenses-content').innerHTML = markdownToHTML(licMD);
      document.getElementById('architecture-content').innerHTML = markdownToHTML(archMD);
      ${content.changelog ? "if (document.getElementById('changelog-content')) document.getElementById('changelog-content').innerHTML = markdownToHTML(changelogMD);" : ''}
    }
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', renderContent);
    } else {
      renderContent();
    }
  </script>
</body>
</html>`;
}

function markdownToHTML(markdown: string): string {
  // Basic markdown to HTML conversion (simple implementation)
  // In production, use a proper markdown parser
  return markdown
    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
    .replace(/^\* (.*$)/gim, '<li>$1</li>')
    .replace(/^- (.*$)/gim, '<li>$1</li>')
    .replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/gim, '<em>$1</em>')
    .replace(/`([^`]+)`/gim, '<code>$1</code>')
    .replace(/\n\n/gim, '</p><p>')
    .replace(/^(.+)$/gim, '<p>$1</p>');
}
