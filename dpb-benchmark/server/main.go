package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

var (
	Version   = "dev"
	BuildTime = "unknown"
	GitCommit = "unknown"
)

func main() {
	port := flag.Int("port", 8080, "Port to serve on")
	open := flag.Bool("open", true, "Open browser automatically")
	version := flag.Bool("version", false, "Show version information")
	flag.Parse()

	if *version {
		fmt.Printf("dependency-buster Dashboard Server\n")
		fmt.Printf("Version: %s\n", Version)
		fmt.Printf("Build Time: %s\n", BuildTime)
		fmt.Printf("Git Commit: %s\n", GitCommit)
		os.Exit(0)
	}

	// Find dashboard directory (relative to this binary or workspace)
	dashboardDir := findDashboardDir()
	if dashboardDir == "" {
		log.Fatal("Could not find dashboard directory")
	}

	// Auto-generate docs on first startup (if they don't exist)
	go autoGenerateDocs(dashboardDir)

	// Find workspace root to serve docs from multiple locations
	workspaceRoot := findWorkspaceRoot(dashboardDir)
	
	// Create file server for dashboard
	fs := http.FileServer(http.Dir(dashboardDir))
	http.Handle("/", fs)
	
	// Serve docs from multiple locations if workspace root found
	if workspaceRoot != "" {
		// Serve docs-typescript, docs-go, docs-rust, and docs directories
		docsDirs := []string{
			filepath.Join(workspaceRoot, "docs-typescript"),
			filepath.Join(workspaceRoot, "docs-go"),
			filepath.Join(workspaceRoot, "docs-rust"),
			filepath.Join(workspaceRoot, "docs"),
		}
		
		for _, docsDir := range docsDirs {
			if _, err := os.Stat(docsDir); err == nil {
				// Serve each docs directory at /docs-{name}/ or /docs/
				dirName := filepath.Base(docsDir)
				if dirName == "docs" {
					http.Handle("/docs/", http.StripPrefix("/docs/", http.FileServer(http.Dir(docsDir))))
				} else {
					http.Handle("/"+dirName+"/", http.StripPrefix("/"+dirName+"/", http.FileServer(http.Dir(docsDir))))
				}
			}
		}
	}

	addr := fmt.Sprintf(":%d", *port)
	url := fmt.Sprintf("http://localhost%s", addr)

	fmt.Println()
	fmt.Println("┌─────────────────────────────────────────────────────────┐")
	fmt.Println("│  dependency-buster // Dashboard Server                  │")
	fmt.Println("├─────────────────────────────────────────────────────────┤")
	fmt.Printf("│  ▶ Version:  %-42s│\n", Version)
	fmt.Printf("│  ▶ Serving:  %-42s│\n", dashboardDir)
	fmt.Printf("│  ▶ URL:      %-42s│\n", url)
	fmt.Printf("│  ▶ Started:  %-42s│\n", time.Now().Format("2006-01-02 15:04:05"))
	fmt.Println("│  ▶ Press Ctrl+C to stop                                 │")
	fmt.Println("└─────────────────────────────────────────────────────────┘")
	fmt.Println()

	// Open browser
	if *open {
		openBrowser(url)
	}

	log.Fatal(http.ListenAndServe(addr, nil))
}

func findDashboardDir() string {
	// Try relative paths
	candidates := []string{
		"../dashboard",
		"./dashboard",
		"../../dpb-benchmark/dashboard",
		"../dpb-benchmark/dashboard",
	}

	// Get executable directory
	if exe, err := os.Executable(); err == nil {
		exeDir := filepath.Dir(exe)
		candidates = append(candidates,
			filepath.Join(exeDir, "../dashboard"),
			filepath.Join(exeDir, "../../dpb-benchmark/dashboard"),
		)
	}

	// Get working directory
	if wd, err := os.Getwd(); err == nil {
		candidates = append(candidates,
			filepath.Join(wd, "dashboard"),
			filepath.Join(wd, "dpb-benchmark/dashboard"),
		)
	}

	for _, dir := range candidates {
		absDir, _ := filepath.Abs(dir)
		indexPath := filepath.Join(absDir, "index.html")
		if _, err := os.Stat(indexPath); err == nil {
			return absDir
		}
	}

	return ""
}

func openBrowser(url string) {
	var cmd *exec.Cmd
	switch runtime.GOOS {
	case "darwin":
		cmd = exec.Command("open", url)
	case "linux":
		cmd = exec.Command("xdg-open", url)
	case "windows":
		cmd = exec.Command("cmd", "/c", "start", url)
	default:
		return
	}
	cmd.Start()
}

// autoGenerateDocs generates documentation and runs benchmark on first server startup
func autoGenerateDocs(dashboardDir string) {
	// Wait a bit for server to start
	time.Sleep(2 * time.Second)

	// Find workspace root (go up from dashboard directory)
	workspaceRoot := findWorkspaceRoot(dashboardDir)
	if workspaceRoot == "" {
		return
	}

	// Check if docs already exist
	docsDir := filepath.Join(workspaceRoot, "docs")
	indexPath := filepath.Join(docsDir, "index.md")
	docsExist := false
	if _, err := os.Stat(indexPath); err == nil {
		docsExist = true
	}

	// Find test repository or workspace itself
	repoPath := findTestRepo(workspaceRoot)
	if repoPath == "" {
		repoPath = workspaceRoot
	}

	// Check which implementations are available
	tsServerPath := filepath.Join(workspaceRoot, "dpb-mcp-typescript", "build", "server.js")
	goBinaryPath := filepath.Join(workspaceRoot, "dpb-mcp-go", "build", "dpb-mcp")
	rustBinaryPath := filepath.Join(workspaceRoot, "dpb-mcp-rust", "target", "release", "dpb-mcp")

	hasTS := fileExists(tsServerPath)
	hasGo := fileExists(goBinaryPath)
	hasRust := fileExists(rustBinaryPath)

	if !hasTS && !hasGo && !hasRust {
		// No implementations available, skip
		return
	}

	fmt.Println()
	fmt.Println("┌─────────────────────────────────────────────────────────┐")
	fmt.Println("│  First Run: Generating Docs & Benchmarking              │")
	fmt.Println("├─────────────────────────────────────────────────────────┤")
	fmt.Printf("│  ▶ Repository: %-40s│\n", repoPath)
	if !docsExist {
		fmt.Printf("│  ▶ Output:     %-40s│\n", docsDir)
	}
	fmt.Printf("│  ▶ TypeScript: %-40s│\n", statusString(hasTS))
	fmt.Printf("│  ▶ Go:         %-40s│\n", statusString(hasGo))
	fmt.Printf("│  ▶ Rust:       %-40s│\n", statusString(hasRust))
	fmt.Println("└─────────────────────────────────────────────────────────┘")
	fmt.Println()

	// Generate docs with all available implementations
	successCount := 0
	if hasTS {
		if generateDocsWithImpl("TypeScript", "node", tsServerPath, repoPath, docsDir) {
			successCount++
		}
	}
	if hasGo {
		if generateDocsWithImpl("Go", goBinaryPath, "", repoPath, docsDir) {
			successCount++
		}
	}
	if hasRust {
		if generateDocsWithImpl("Rust", rustBinaryPath, "", repoPath, docsDir) {
			successCount++
		}
	}

	if successCount > 0 {
		fmt.Printf("✓ Documentation generated with %d implementation(s)!\n", successCount)
		if !docsExist {
			fmt.Printf("  View at: %s\n", docsDir)
		}
		fmt.Println()
	}

	// Run benchmark for generate_mkdocs_docs tool
	fmt.Println("┌─────────────────────────────────────────────────────────┐")
	fmt.Println("│  Benchmarking Documentation Generation                  │")
	fmt.Println("└─────────────────────────────────────────────────────────┘")
	fmt.Println()

	benchmarkResults := make(map[string]int64)
	if hasTS {
		benchmarkResults["TypeScript"] = benchmarkDocsGeneration("TypeScript", "node", tsServerPath, repoPath)
	}
	if hasGo {
		benchmarkResults["Go"] = benchmarkDocsGeneration("Go", goBinaryPath, "", repoPath)
	}
	if hasRust {
		benchmarkResults["Rust"] = benchmarkDocsGeneration("Rust", rustBinaryPath, "", repoPath)
	}

	// Display results
	if len(benchmarkResults) > 0 {
		fmt.Println("Benchmark Results:")
		for impl, timeMs := range benchmarkResults {
			fmt.Printf("  %s: %d ms\n", impl, timeMs)
		}
		fmt.Println()
	}
}

func statusString(available bool) string {
	if available {
		return "Available"
	}
	return "Not built"
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func generateDocsWithImpl(implName, cmd, arg, repoPath, docsDir string) bool {
	request := map[string]interface{}{
		"jsonrpc": "2.0",
		"method":  "tools/call",
		"params": map[string]interface{}{
			"name": "generate_mkdocs_docs",
			"arguments": map[string]interface{}{
				"repo_path":        repoPath,
				"output_dir":       docsDir,
				"include_changelog": true,
				"format":            "mkdocs",
			},
		},
		"id": 1,
	}

	requestJSON, err := json.Marshal(request)
	if err != nil {
		return false
	}

	var execCmd *exec.Cmd
	if arg != "" {
		execCmd = exec.Command(cmd, arg)
	} else {
		execCmd = exec.Command(cmd)
	}
	execCmd.Stdin = strings.NewReader(string(requestJSON))
	output, err := execCmd.CombinedOutput()
	if err != nil {
		return false
	}

	success := strings.Contains(string(output), "successfully") || strings.Contains(string(output), "Documentation generated")
	if success {
		fmt.Printf("  ✓ %s: Generated\n", implName)
	}
	return success
}

func benchmarkDocsGeneration(implName, cmd, arg, repoPath string) int64 {
	request := map[string]interface{}{
		"jsonrpc": "2.0",
		"method":  "tools/call",
		"params": map[string]interface{}{
			"name": "generate_mkdocs_docs",
			"arguments": map[string]interface{}{
				"repo_path":        repoPath,
				"output_dir":       filepath.Join(filepath.Dir(repoPath), "docs_benchmark_"+strings.ToLower(implName)),
				"include_changelog": false, // Faster for benchmark
				"format":            "mkdocs",
			},
		},
		"id": 1,
	}

	requestJSON, err := json.Marshal(request)
	if err != nil {
		return -1
	}

	start := time.Now()
	var execCmd *exec.Cmd
	if arg != "" {
		execCmd = exec.Command(cmd, arg)
	} else {
		execCmd = exec.Command(cmd)
	}
	execCmd.Stdin = strings.NewReader(string(requestJSON))
	execCmd.Run() // Ignore errors for benchmark
	elapsed := time.Since(start)

	return elapsed.Milliseconds()
}

func findWorkspaceRoot(dashboardDir string) string {
	// Try to find workspace root by going up from dashboard directory
	dir := dashboardDir
	for i := 0; i < 5; i++ {
		// Check if this looks like workspace root (has dpb-mcp-typescript, dpb-mcp-go, etc.)
		if _, err := os.Stat(filepath.Join(dir, "dpb-mcp-typescript")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return ""
}

func findTestRepo(workspaceRoot string) string {
	// Check for test-repos directory
	testReposDir := filepath.Join(workspaceRoot, "test-repos")
	if _, err := os.Stat(testReposDir); err == nil {
		// Find first subdirectory
		entries, err := os.ReadDir(testReposDir)
		if err == nil {
			for _, entry := range entries {
				if entry.IsDir() {
					repoPath := filepath.Join(testReposDir, entry.Name())
					// Check if it has composer.json (PHP project)
					if _, err := os.Stat(filepath.Join(repoPath, "composer.json")); err == nil {
						return repoPath
					}
				}
			}
		}
	}
	return ""
}
