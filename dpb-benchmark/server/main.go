package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

var (
	Version   = "dev"
	BuildTime = "unknown"
	GitCommit = "unknown"
)

func main() {
	port := flag.Int("port", 8080, "Port to serve on")
	open := flag.Bool("open", true, "Open browser automatically")
	version := flag.Bool("version", false, "Show version information")
	flag.Parse()

	if *version {
		fmt.Printf("dependency-buster Dashboard Server\n")
		fmt.Printf("Version: %s\n", Version)
		fmt.Printf("Build Time: %s\n", BuildTime)
		fmt.Printf("Git Commit: %s\n", GitCommit)
		os.Exit(0)
	}

	// Find dashboard directory (relative to this binary or workspace)
	dashboardDir := findDashboardDir()
	if dashboardDir == "" {
		log.Fatal("Could not find dashboard directory")
	}

	// Auto-generate docs on first startup (if they don't exist)
	go autoGenerateDocs(dashboardDir)

	// Create file server
	fs := http.FileServer(http.Dir(dashboardDir))
	http.Handle("/", fs)

	addr := fmt.Sprintf(":%d", *port)
	url := fmt.Sprintf("http://localhost%s", addr)

	fmt.Println()
	fmt.Println("┌─────────────────────────────────────────────────────────┐")
	fmt.Println("│  dependency-buster // Dashboard Server                  │")
	fmt.Println("├─────────────────────────────────────────────────────────┤")
	fmt.Printf("│  ▶ Version:  %-42s│\n", Version)
	fmt.Printf("│  ▶ Serving:  %-42s│\n", dashboardDir)
	fmt.Printf("│  ▶ URL:      %-42s│\n", url)
	fmt.Printf("│  ▶ Started:  %-42s│\n", time.Now().Format("2006-01-02 15:04:05"))
	fmt.Println("│  ▶ Press Ctrl+C to stop                                 │")
	fmt.Println("└─────────────────────────────────────────────────────────┘")
	fmt.Println()

	// Open browser
	if *open {
		openBrowser(url)
	}

	log.Fatal(http.ListenAndServe(addr, nil))
}

func findDashboardDir() string {
	// Try relative paths
	candidates := []string{
		"../dashboard",
		"./dashboard",
		"../../dpb-benchmark/dashboard",
		"../dpb-benchmark/dashboard",
	}

	// Get executable directory
	if exe, err := os.Executable(); err == nil {
		exeDir := filepath.Dir(exe)
		candidates = append(candidates,
			filepath.Join(exeDir, "../dashboard"),
			filepath.Join(exeDir, "../../dpb-benchmark/dashboard"),
		)
	}

	// Get working directory
	if wd, err := os.Getwd(); err == nil {
		candidates = append(candidates,
			filepath.Join(wd, "dashboard"),
			filepath.Join(wd, "dpb-benchmark/dashboard"),
		)
	}

	for _, dir := range candidates {
		absDir, _ := filepath.Abs(dir)
		indexPath := filepath.Join(absDir, "index.html")
		if _, err := os.Stat(indexPath); err == nil {
			return absDir
		}
	}

	return ""
}

func openBrowser(url string) {
	var cmd *exec.Cmd
	switch runtime.GOOS {
	case "darwin":
		cmd = exec.Command("open", url)
	case "linux":
		cmd = exec.Command("xdg-open", url)
	case "windows":
		cmd = exec.Command("cmd", "/c", "start", url)
	default:
		return
	}
	cmd.Start()
}

// autoGenerateDocs generates documentation on first server startup if docs don't exist
func autoGenerateDocs(dashboardDir string) {
	// Wait a bit for server to start
	time.Sleep(2 * time.Second)

	// Find workspace root (go up from dashboard directory)
	workspaceRoot := findWorkspaceRoot(dashboardDir)
	if workspaceRoot == "" {
		return
	}

	// Check if docs already exist
	docsDir := filepath.Join(workspaceRoot, "docs")
	indexPath := filepath.Join(docsDir, "index.md")
	if _, err := os.Stat(indexPath); err == nil {
		// Docs already exist, skip generation
		return
	}

	// Find test repository or workspace itself
	repoPath := findTestRepo(workspaceRoot)
	if repoPath == "" {
		repoPath = workspaceRoot
	}

	// Check if TypeScript server exists
	tsServerPath := filepath.Join(workspaceRoot, "dpb-mcp-typescript", "build", "server.js")
	if _, err := os.Stat(tsServerPath); err != nil {
		// TypeScript server not built, skip
		return
	}

	fmt.Println()
	fmt.Println("┌─────────────────────────────────────────────────────────┐")
	fmt.Println("│  Generating Documentation (First Time)                  │")
	fmt.Println("├─────────────────────────────────────────────────────────┤")
	fmt.Printf("│  ▶ Repository: %-40s│\n", repoPath)
	fmt.Printf("│  ▶ Output:     %-40s│\n", docsDir)
	fmt.Println("└─────────────────────────────────────────────────────────┘")
	fmt.Println()

	// Call generate_mkdocs_docs via TypeScript MCP server
	request := map[string]interface{}{
		"jsonrpc": "2.0",
		"method":  "tools/call",
		"params": map[string]interface{}{
			"name": "generate_mkdocs_docs",
			"arguments": map[string]interface{}{
				"repo_path":        repoPath,
				"output_dir":       docsDir,
				"include_changelog": true,
				"format":            "mkdocs",
			},
		},
		"id": 1,
	}

	requestJSON, err := json.Marshal(request)
	if err != nil {
		return
	}

	cmd := exec.Command("node", tsServerPath)
	cmd.Stdin = strings.NewReader(string(requestJSON))
	output, err := cmd.CombinedOutput()
	if err != nil {
		// Silent failure - docs generation is optional
		return
	}

	// Check if generation was successful
	if strings.Contains(string(output), "successfully") || strings.Contains(string(output), "Documentation generated") {
		fmt.Println("✓ Documentation generated successfully!")
		fmt.Printf("  View at: %s\n", docsDir)
		fmt.Println()
	}
}

func findWorkspaceRoot(dashboardDir string) string {
	// Try to find workspace root by going up from dashboard directory
	dir := dashboardDir
	for i := 0; i < 5; i++ {
		// Check if this looks like workspace root (has dpb-mcp-typescript, dpb-mcp-go, etc.)
		if _, err := os.Stat(filepath.Join(dir, "dpb-mcp-typescript")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return ""
}

func findTestRepo(workspaceRoot string) string {
	// Check for test-repos directory
	testReposDir := filepath.Join(workspaceRoot, "test-repos")
	if _, err := os.Stat(testReposDir); err == nil {
		// Find first subdirectory
		entries, err := os.ReadDir(testReposDir)
		if err == nil {
			for _, entry := range entries {
				if entry.IsDir() {
					repoPath := filepath.Join(testReposDir, entry.Name())
					// Check if it has composer.json (PHP project)
					if _, err := os.Stat(filepath.Join(repoPath, "composer.json")); err == nil {
						return repoPath
					}
				}
			}
		}
	}
	return ""
}
