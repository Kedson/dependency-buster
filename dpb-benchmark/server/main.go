package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"time"
)

var (
	Version   = "dev"
	BuildTime = "unknown"
	GitCommit = "unknown"
)

func main() {
	port := flag.Int("port", 8080, "Port to serve on")
	open := flag.Bool("open", true, "Open browser automatically")
	version := flag.Bool("version", false, "Show version information")
	flag.Parse()

	if *version {
		fmt.Printf("dependency-buster Dashboard Server\n")
		fmt.Printf("Version: %s\n", Version)
		fmt.Printf("Build Time: %s\n", BuildTime)
		fmt.Printf("Git Commit: %s\n", GitCommit)
		os.Exit(0)
	}

	// Find dashboard directory (relative to this binary or workspace)
	dashboardDir := findDashboardDir()
	if dashboardDir == "" {
		log.Fatal("Could not find dashboard directory")
	}

	// Auto-generate docs on first startup (if they don't exist)
	// Generates HTML documentation using all three implementations (TypeScript, Go, Rust)
	// Each implementation creates its own docs directory: docs-typescript/, docs-go/, docs-rust/
	// See RELEASE_NOTES.md v1.1.0 for details on native HTML generation
	go autoGenerateDocs(dashboardDir)

	// Find workspace root to serve docs from multiple locations
	workspaceRoot := findWorkspaceRoot(dashboardDir)
	
	// Create file server for dashboard
	fs := http.FileServer(http.Dir(dashboardDir))
	http.Handle("/", fs)
	
	// Serve docs from multiple locations
	// Supports nested directory structures (e.g., dependency-buster-main/dpb-mcp-workspace/)
	// Each implementation generates docs in its own directory: docs-typescript/, docs-go/, docs-rust/
	docsDirs := []string{}
	
	// Add docs directories from workspace root
	if workspaceRoot != "" {
		docsDirs = append(docsDirs,
			filepath.Join(workspaceRoot, "docs-typescript"), // TypeScript implementation docs
			filepath.Join(workspaceRoot, "docs-go"),         // Go implementation docs
			filepath.Join(workspaceRoot, "docs-rust"),      // Rust implementation docs
			filepath.Join(workspaceRoot, "docs"),            // Generic/fallback docs
		)
	}
	
	// Also check parent directory and current directory for docs
	// Check multiple levels up (up to 4 levels) for common patterns
	// This allows docs to be found even in nested directory structures
	currentDir := dashboardDir
	for i := 0; i < 4; i++ {
		parent := filepath.Dir(currentDir)
		if parent == currentDir {
			break
		}
		// Check for docs directories at this level
		patterns := []string{
			filepath.Join(parent, "docs"),
			filepath.Join(parent, "docs-typescript"),
			filepath.Join(parent, "docs-go"),
			filepath.Join(parent, "docs-rust"),
		}
		docsDirs = append(docsDirs, patterns...)
		currentDir = parent
	}
	
	// Serve all found docs directories
	for _, docsDir := range docsDirs {
		if absDocsDir, err := filepath.Abs(docsDir); err == nil {
			if _, err := os.Stat(absDocsDir); err == nil {
				// Check if index.html exists in this directory
				if _, err := os.Stat(filepath.Join(absDocsDir, "index.html")); err == nil {
					// Serve each docs directory at /docs-{name}/ or /docs/
					dirName := filepath.Base(absDocsDir)
					if dirName == "docs" {
						http.Handle("/docs/", http.StripPrefix("/docs/", http.FileServer(http.Dir(absDocsDir))))
						fmt.Printf("  ✓ Serving docs from: %s\n", absDocsDir)
					} else {
						http.Handle("/"+dirName+"/", http.StripPrefix("/"+dirName+"/", http.FileServer(http.Dir(absDocsDir))))
						fmt.Printf("  ✓ Serving %s from: %s\n", dirName, absDocsDir)
					}
				}
			}
		}
	}

	addr := fmt.Sprintf(":%d", *port)
	url := fmt.Sprintf("http://localhost%s", addr)

	fmt.Println()
	fmt.Println("┌─────────────────────────────────────────────────────────┐")
	fmt.Println("│  dependency-buster // Dashboard Server                  │")
	fmt.Println("├─────────────────────────────────────────────────────────┤")
	fmt.Printf("│  ▶ Version:  %-42s│\n", Version)
	fmt.Printf("│  ▶ Serving:  %-42s│\n", dashboardDir)
	fmt.Printf("│  ▶ URL:      %-42s│\n", url)
	fmt.Printf("│  ▶ Started:  %-42s│\n", time.Now().Format("2006-01-02 15:04:05"))
	if len(docsDirs) > 0 {
		fmt.Println("│  ▶ Docs:     Checking for documentation...              │")
	}
	fmt.Println("│  ▶ Press Ctrl+C to stop                                 │")
	fmt.Println("└─────────────────────────────────────────────────────────┘")
	fmt.Println()

	// Start HTTP server in goroutine
	serverStarted := make(chan bool, 1)
	go func() {
		serverStarted <- true
		if err := http.ListenAndServe(addr, nil); err != nil {
			log.Fatal(err)
		}
	}()

	// Wait for server to start, then open browser
	if *open {
		<-serverStarted
		// Give server a moment to actually start listening
		time.Sleep(300 * time.Millisecond)
		openBrowser(url)
	}

	// Block forever to keep server running
	select {}
}

func findDashboardDir() string {
	// Try relative paths
	candidates := []string{
		"../dashboard",
		"./dashboard",
		"../../dpb-benchmark/dashboard",
		"../dpb-benchmark/dashboard",
	}

	// Get executable directory
	if exe, err := os.Executable(); err == nil {
		exeDir := filepath.Dir(exe)
		candidates = append(candidates,
			filepath.Join(exeDir, "../dashboard"),
			filepath.Join(exeDir, "../../dpb-benchmark/dashboard"),
		)
	}

	// Get working directory
	if wd, err := os.Getwd(); err == nil {
		candidates = append(candidates,
			filepath.Join(wd, "dashboard"),
			filepath.Join(wd, "dpb-benchmark/dashboard"),
		)
	}

	for _, dir := range candidates {
		absDir, _ := filepath.Abs(dir)
		indexPath := filepath.Join(absDir, "index.html")
		if _, err := os.Stat(indexPath); err == nil {
			return absDir
		}
	}

	return ""
}

func openBrowser(url string) {
	var cmd *exec.Cmd
	switch runtime.GOOS {
	case "darwin":
		cmd = exec.Command("open", url)
	case "linux":
		cmd = exec.Command("xdg-open", url)
	case "windows":
		cmd = exec.Command("cmd", "/c", "start", url)
	default:
		return
	}
	cmd.Start()
}

// autoGenerateDocs generates documentation and runs benchmark on first server startup.
// This function implements the auto-generation feature introduced in v1.1.0.
//
// Features:
//   - Generates HTML documentation using all available implementations (TypeScript, Go, Rust)
//   - Each implementation creates its own docs directory (docs-typescript/, docs-go/, docs-rust/)
//   - Uses native HTML generation (no Python/MkDocs required)
//   - Benchmarks documentation generation and injects results into dashboard HTML
//   - Only runs on first startup if HTML docs don't already exist
//
// See RELEASE_NOTES.md v1.1.0 for details on native HTML generation.
func autoGenerateDocs(dashboardDir string) {
	// Find dashboard HTML file path (used for injecting benchmark data)
	dashboardFile := filepath.Join(dashboardDir, "index.html")
	// Wait a bit for server to start before generating docs
	time.Sleep(2 * time.Second)

	// Find workspace root (go up from dashboard directory)
	workspaceRoot := findWorkspaceRoot(dashboardDir)
	if workspaceRoot == "" {
		return
	}

	// Check if HTML docs already exist (we always want HTML for viewing)
	// Generate to separate folders for each implementation to allow comparison
	// Each implementation generates: docs-typescript/, docs-go/, docs-rust/
	docsTSDir := filepath.Join(workspaceRoot, "docs-typescript")
	docsGoDir := filepath.Join(workspaceRoot, "docs-go")
	docsRustDir := filepath.Join(workspaceRoot, "docs-rust")
	
	// Only skip if HTML exists (markdown alone is not enough - we need HTML for browser viewing)
	// Check all possible locations for existing HTML documentation
	htmlExists := fileExists(filepath.Join(docsTSDir, "index.html")) ||
		fileExists(filepath.Join(docsGoDir, "index.html")) ||
		fileExists(filepath.Join(docsRustDir, "index.html")) ||
		fileExists(filepath.Join(workspaceRoot, "docs", "index.html"))

	// Find test repository or workspace itself
	repoPath := findTestRepo(workspaceRoot)
	if repoPath == "" {
		repoPath = workspaceRoot
	}

	// Check which implementations are available
	tsServerPath := filepath.Join(workspaceRoot, "dpb-mcp-typescript", "build", "server.js")
	goBinaryPath := filepath.Join(workspaceRoot, "dpb-mcp-go", "build", "dpb-mcp")
	rustBinaryPath := filepath.Join(workspaceRoot, "dpb-mcp-rust", "target", "release", "dpb-mcp")

	hasTS := fileExists(tsServerPath)
	hasGo := fileExists(goBinaryPath)
	hasRust := fileExists(rustBinaryPath)

	if !hasTS && !hasGo && !hasRust {
		// No implementations available, skip
		return
	}

	// Only generate if HTML doesn't exist
	if htmlExists {
		fmt.Println()
		fmt.Println("┌─────────────────────────────────────────────────────────┐")
		fmt.Println("│  Documentation Already Exists (HTML format)              │")
		fmt.Println("└─────────────────────────────────────────────────────────┘")
		fmt.Println()
		return
	}

	fmt.Println()
	fmt.Println("┌─────────────────────────────────────────────────────────┐")
	fmt.Println("│  First Run: Generating HTML Documentation                │")
	fmt.Println("├─────────────────────────────────────────────────────────┤")
	fmt.Printf("│  ▶ Repository: %-40s│\n", repoPath)
	fmt.Printf("│  ▶ Output:     docs-typescript/, docs-go/, docs-rust/   │\n")
	fmt.Printf("│  ▶ Format:     HTML (no Python required)                 │\n")
	fmt.Printf("│  ▶ TypeScript: %-40s│\n", statusString(hasTS))
	fmt.Printf("│  ▶ Go:         %-40s│\n", statusString(hasGo))
	fmt.Printf("│  ▶ Rust:       %-40s│\n", statusString(hasRust))
	fmt.Println("└─────────────────────────────────────────────────────────┘")
	fmt.Println()

	// Generate docs with all available implementations to separate folders
	successCount := 0
	if hasTS {
		if generateDocsWithImpl("TypeScript", "node", tsServerPath, repoPath, docsTSDir) {
			successCount++
		}
	}
	if hasGo {
		if generateDocsWithImpl("Go", goBinaryPath, "", repoPath, docsGoDir) {
			successCount++
		}
	}
	if hasRust {
		if generateDocsWithImpl("Rust", rustBinaryPath, "", repoPath, docsRustDir) {
			successCount++
		}
	}

	if successCount > 0 {
		fmt.Printf("✓ HTML documentation generated with %d implementation(s)!\n", successCount)
		fmt.Printf("  • TypeScript: %s/index.html\n", docsTSDir)
		fmt.Printf("  • Go:         %s/index.html\n", docsGoDir)
		fmt.Printf("  • Rust:       %s/index.html\n", docsRustDir)
		fmt.Printf("\n  View in dashboard: Click 'View Documentation' menu item\n")
		fmt.Println()
	}

	// Run benchmark for generate_mkdocs_docs tool
	fmt.Println("┌─────────────────────────────────────────────────────────┐")
	fmt.Println("│  Benchmarking Documentation Generation                  │")
	fmt.Println("└─────────────────────────────────────────────────────────┘")
	fmt.Println()

	benchmarkResults := make(map[string]int64)
	if hasTS {
		benchmarkResults["TypeScript"] = benchmarkDocsGeneration("TypeScript", "node", tsServerPath, repoPath)
	}
	if hasGo {
		benchmarkResults["Go"] = benchmarkDocsGeneration("Go", goBinaryPath, "", repoPath)
	}
	if hasRust {
		benchmarkResults["Rust"] = benchmarkDocsGeneration("Rust", rustBinaryPath, "", repoPath)
	}

	// Display results
	if len(benchmarkResults) > 0 {
		fmt.Println("Benchmark Results:")
		for impl, timeMs := range benchmarkResults {
			fmt.Printf("  %s: %d ms\n", impl, timeMs)
		}
		fmt.Println()
		
		// Inject benchmark results into dashboard HTML
		injectDocsBenchmarkIntoDashboard(dashboardFile, benchmarkResults)
	}
}

func injectDocsBenchmarkIntoDashboard(dashboardFile string, docsBenchmarks map[string]int64) {
	if _, err := os.Stat(dashboardFile); err != nil {
		return // Dashboard file doesn't exist
	}
	
	// Read dashboard HTML
	htmlBytes, err := os.ReadFile(dashboardFile)
	if err != nil {
		return
	}
	html := string(htmlBytes)
	
	// Find existing benchmark data
	benchmarkRegex := regexp.MustCompile(`/\*BENCHMARK_DATA\*/(.*?)/\*END_BENCHMARK_DATA\*/`)
	matches := benchmarkRegex.FindStringSubmatch(html)
	if len(matches) < 2 {
		return // No benchmark data placeholder found
	}
	
	// Parse existing benchmark data
	var existingBenchmarks map[string]map[string]interface{}
	if err := json.Unmarshal([]byte(matches[1]), &existingBenchmarks); err != nil {
		// If parsing fails, create new structure
		existingBenchmarks = make(map[string]map[string]interface{})
	}
	
	// Merge docs generation benchmarks into existing data
	for impl, timeMs := range docsBenchmarks {
		if existingBenchmarks[impl] == nil {
			existingBenchmarks[impl] = make(map[string]interface{})
		}
		existingBenchmarks[impl]["generate_mkdocs_docs"] = timeMs
	}
	
	// Convert back to JSON
	updatedJSON, err := json.Marshal(existingBenchmarks)
	if err != nil {
		return
	}
	
	// Replace benchmark data in HTML
	newBenchmarkData := fmt.Sprintf("/*BENCHMARK_DATA*/%s/*END_BENCHMARK_DATA*/", string(updatedJSON))
	html = benchmarkRegex.ReplaceAllString(html, newBenchmarkData)
	
	// Write back to file
	if err := os.WriteFile(dashboardFile, []byte(html), 0644); err != nil {
		fmt.Printf("  ⚠ Could not update dashboard with docs benchmarks: %v\n", err)
		return
	}
	
	fmt.Printf("  ✓ Documentation generation benchmarks injected into dashboard\n")
}

func statusString(available bool) string {
	if available {
		return "Available"
	}
	return "Not built"
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// generateDocsWithImpl generates documentation using a specific implementation.
// Calls the generate_mkdocs_docs tool via JSON-RPC with format="html" to use
// native HTML generation (no Python required). See RELEASE_NOTES.md v1.1.0.
func generateDocsWithImpl(implName, cmd, arg, repoPath, docsDir string) bool {
	request := map[string]interface{}{
		"jsonrpc": "2.0",
		"method":  "tools/call",
		"params": map[string]interface{}{
			"name": "generate_mkdocs_docs",
			"arguments": map[string]interface{}{
				"repo_path":        repoPath,
				"output_dir":       docsDir,
				"include_changelog": true,
				"format":            "html", // Native HTML generation (v1.1.0)
			},
		},
		"id": 1,
	}

	requestJSON, err := json.Marshal(request)
	if err != nil {
		return false
	}

	var execCmd *exec.Cmd
	if arg != "" {
		execCmd = exec.Command(cmd, arg)
	} else {
		execCmd = exec.Command(cmd)
	}
	execCmd.Stdin = strings.NewReader(string(requestJSON))
	output, err := execCmd.CombinedOutput()
	if err != nil {
		return false
	}

	success := strings.Contains(string(output), "successfully") || strings.Contains(string(output), "Documentation generated")
	if success {
		fmt.Printf("  ✓ %s: Generated\n", implName)
	}
	return success
}

// benchmarkDocsGeneration benchmarks documentation generation for a specific implementation.
// Returns elapsed time in milliseconds. Uses format="html" for native generation.
// See RELEASE_NOTES.md v1.1.0 for performance metrics.
func benchmarkDocsGeneration(implName, cmd, arg, repoPath string) int64 {
	request := map[string]interface{}{
		"jsonrpc": "2.0",
		"method":  "tools/call",
		"params": map[string]interface{}{
			"name": "generate_mkdocs_docs",
			"arguments": map[string]interface{}{
				"repo_path":        repoPath,
				"output_dir":       filepath.Join(filepath.Dir(repoPath), "docs_benchmark_"+strings.ToLower(implName)),
				"include_changelog": false, // Faster for benchmark (skip changelog)
				"format":            "html", // Native HTML generation (v1.1.0)
			},
		},
		"id": 1,
	}

	requestJSON, err := json.Marshal(request)
	if err != nil {
		return -1
	}

	start := time.Now()
	var execCmd *exec.Cmd
	if arg != "" {
		execCmd = exec.Command(cmd, arg)
	} else {
		execCmd = exec.Command(cmd)
	}
	execCmd.Stdin = strings.NewReader(string(requestJSON))
	execCmd.Run() // Ignore errors for benchmark
	elapsed := time.Since(start)

	return elapsed.Milliseconds()
}

func findWorkspaceRoot(dashboardDir string) string {
	// Try to find workspace root by going up from dashboard directory
	dir := dashboardDir
	for i := 0; i < 5; i++ {
		// Check if this looks like workspace root (has dpb-mcp-typescript, dpb-mcp-go, etc.)
		if _, err := os.Stat(filepath.Join(dir, "dpb-mcp-typescript")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return ""
}

func findTestRepo(workspaceRoot string) string {
	// Check for test-repos directory
	testReposDir := filepath.Join(workspaceRoot, "test-repos")
	if _, err := os.Stat(testReposDir); err == nil {
		// Find first subdirectory
		entries, err := os.ReadDir(testReposDir)
		if err == nil {
			for _, entry := range entries {
				if entry.IsDir() {
					repoPath := filepath.Join(testReposDir, entry.Name())
					// Check if it has composer.json (PHP project)
					if _, err := os.Stat(filepath.Join(repoPath, "composer.json")); err == nil {
						return repoPath
					}
				}
			}
		}
	}
	return ""
}
